


<!DOCTYPE html>
<html>
<head>
	<meta name="author" content="Андрій Соколов">
	<meta charset="UTF-8">
</head>

<body>

  

<svg id="svg-qubit" width="320" height="320"
	xmlns="http://www.w3.org/2000/svg">

	<!-- Axes arrow -->
	<marker id="triangle"
		viewBox="0 0 2 2" refX="0" refY="1" 
		markerUnits="userSpaceOnUse"
		markerWidth="10.0" markerHeight="10.0"
		orient="auto">
		<path d="M 0 0 L 2 1 L 0 2 z" fill="gray" />
	</marker>

	<!-- Red arrow for the qubit Bloch vector  -->
	<marker id="qu-triangle"
		viewBox="0 0 2 2" refX="0" refY="1" 
		markerUnits="userSpaceOnUse"
		preserveAspectRatio="none"
		markerWidth="10.0" markerHeight="10.0"
		orient="auto">
		<path d="M 0 0 L 2 1 L 0 2 z" fill="red"/>
	</marker>

	<!-- Axes and the Bloch sphere -->
	<g stroke="gray" fill="gray">

	<g id="xy">

	<circle cx="0" cy="0" r="1" fill="transparent"
		transform="matrix(-86.6000, 50.0, 100, 0, 160.0, 160.0)"
		vector-effect="non-scaling-stroke"/>

	<line x1="160.0" y1="160.0" x2="30.0" y2="235.00"
		marker-end="url(#triangle)"/> <!-- 0x -->

	<line x1="160.0" y1="160.0" x2="310.0" y2="160.0"
		marker-end="url(#triangle)"/> <!-- 0y -->

	</g>

	<g id="z">

	<line x1="160.0" y1="160.0" x2="160.0" y2="10.0"
		marker-end="url(#triangle)"/> <!-- 0z -->
	
	<circle cx="160.0" cy="160.0" r="100" fill="transparent"/>

	</g>

	</g>

	<!-- Labels -->
	<g fill="black">

	<text x="30.0" y="255.00"> x </text>
	<text x="310.0" y="177.0"> y </text>
	<text x="170.0" y="10.0"> z </text>

	<g id="points" fill="black">
	<circle cx="160.0" cy="60.0" r="3"/>
	<circle cx="160.0" cy="260.0" r="3"/>
	</g>

	<text x="165.0" y="53.0"> |1⟩ </text>
	<text x="165.0" y="277.0"> |0⟩ </text>

	</g>

	<!-- The Bloch vector projection eye-helpers -->
	<g id="xyhelpers" stroke="gray" stroke-width=1 stroke-dasharray="2 2">
	<line id="helpx" x1="160.0" y1="160.0" x2="160.0" y2="160.0"/>
	<line id="helpy" x1="160.0" y1="160.0" x2="160.0" y2="160.0"/>
	</g>
	<line id="helpxy" x1="160.0" y1="160.0" x2="160.0" y2="160.0"
		stroke="gray" stroke-width=1 stroke-dasharray="2 2"/>
	<!-- Bloch vector projections on 0x and 0y -->
	<g id="projs" stroke="black" stroke-width=1>
	<line id="projx" x1="160.0" y1="160.0" x2="160.0" y2="160.0"/>
	<line id="projy" x1="160.0" y1="160.0" x2="160.0" y2="160.0"/>
	</g>

	<!-- Bloch vector; length is 0.9 due to the arrowhead -->
	<line id="bloch-vector" x1="160.0" y1="160.0" x2="160.0" y2="250.0"
		stroke="red" stroke-width=3 marker-end="url(#qu-triangle)"/>

	<!-- Redraw elements if they are in front of the Bloch vector -->
	<g id="overxy" opacity="1">
	<use xlink:href="#xy" stroke="gray"/>
	<use xlink:href="#xyhelpers"/>
	<use xlink:href="#projs"/>
	</g>

	<g id="overz" opacity="0">
	<use xlink:href="#z" stroke="gray"/>
	<use xlink:href="#points"/>
	</g>

	<use id="overhelpxy" xlink:href="#helpxy"/>

	<!-- Trace of the Bloch vector tip -->
	<path id="trace" d="M 160.0 260.0" fill="transparent" stroke="blue"/>

	<!-- Rotation buttons -->
	<g opacity="0">
	<polygon points="160.0,160.0 30.0,250.0 30.0,220.0"
		onmousedown="Wx = W" onmouseup="Wx = 0"/>
	<polygon points="160.0,160.0 310.0,175.00 310.0,145.00"
		onmousedown="Wy = W" onmouseup="Wy = 0"/>
	<polygon points="160.0,160.0 145.00,10.0 175.00,10.0"
		onmousedown="Wz = W" onmouseup="Wz = 0"/>
	</g>

</svg>

<script>


function Spin(doc) {

this.Sx = 0; this.Sy = 0; this.Sz = -1

this.advance_paulis = function(dt, Wx, Wy, Wz)
{
	this.Sx += (Wy*this.Sz - Wz*this.Sy)*dt
	this.Sy += (-Wx*this.Sz + Wz*this.Sx)*dt
	this.Sz += (Wx*this.Sy - Wy*this.Sx)*dt
}

} // end Spin


function cabinet_projector(theta)
{
	const pi = Math.PI, sin = Math.sin, cos = Math.cos

	return function project(x, y, z) {
		var	px = y - x*sin(pi*theta/180),
			py = z - x*cos(pi*theta/180) 

		return [px, py]
	}
}


function SpinView(spin, doc, projector) {

this.trace_on = false
this.s = spin

var proj = projector
if(typeof proj === 'undefined')
	proj = cabinet_projector(60)

var bloch_vec = doc.getElementById("bloch-vector")
	projx = doc.getElementById("projx"),
	projy = doc.getElementById("projy"),
	helpx = doc.getElementById("helpx"),
	helpy = doc.getElementById("helpy"),
	helpxy = doc.getElementById("helpxy"),
	qu_head = doc.getElementById("qu-triangle"),
	overxy = doc.getElementById("overxy"),
	overz = doc.getElementById("overz"),
	overhelpxy = doc.getElementById("overhelpxy"),
	trace = doc.getElementById("trace")

function move_bloch_vector()
{
	var xy = proj(this.s.Sx, this.s.Sy, this.s.Sz)
	var x = xy[0], y = xy[1]

	var scr_bx = 0.9*x*100 + 160.0,
		scr_by = 0.9*y*-100 + 160.0; // vector shaft tip
	bloch_vec.setAttribute("x2", scr_bx)
	bloch_vec.setAttribute("y2", scr_by)
	scr_bx = x*100 + 160.0; scr_by = y*-100 + 160.0; // shaft + arrowhead
	// set the arrowhead length
	qu_head.setAttribute("markerWidth",
		0.1*Math.sqrt(10000*x*x + 10000*y*y))

	return {x:scr_bx, y:scr_by}
}

function correct_depth_order()
{
	// Behind or over the XY plane elements?
	overxy.setAttribute("opacity", 1*(this.s.Sz < 0))
	// ... the 0z axis?
	overz.setAttribute("opacity", 1*(this.s.Sx < 0))
	// ... the xy plane projection helper
	overhelpxy.setAttribute("opacity", 1*(this.s.Sx > 0))
}

function move_projections(scr_b)
{
	var scr_pyx = this.s.Sy*100 + 160.0, scr_pzy = this.s.Sz*-100 + 160.0;
	projy.setAttribute("x2", scr_pyx)
	xy = proj(this.s.Sx, 0, 0)
	x = xy[0], y = xy[1]
	var scr_pxx = x*100 + 160.0, scr_pxy = y*-100 + 160.0
	projx.setAttribute("x2", scr_pxx)
	projx.setAttribute("y2", scr_pxy)

	xy = proj(this.s.Sx, this.s.Sy, 0)
	x = xy[0], y = xy[1]
	var scr_pxy_x = x*100 + 160.0, scr_pxy_y = y*-100 + 160.0

	helpx.setAttribute("x1", scr_pxy_x)
	helpx.setAttribute("y1", scr_pxy_y)
	helpy.setAttribute("x1", scr_pxy_x)
	helpy.setAttribute("y1", scr_pxy_y)
	helpx.setAttribute("y2", scr_pxy)
	helpx.setAttribute("x2", scr_pxx)
	helpy.setAttribute("x2", scr_pyx)
	helpxy.setAttribute("x1", scr_pxy_x)
	helpxy.setAttribute("y1", scr_pxy_y)
	helpxy.setAttribute("x2", scr_b.x)
	helpxy.setAttribute("y2", scr_b.y)
}

var trace_add_node = (function() {
	prev_scr_b = {x:Infinity, y:Infinity}
	trace = this.trace

	return function(scr_b) {
		var d = trace.getAttribute("d"),
			// Start a new trace if we are too far away from the old one
			new_trace = Math.abs(prev_scr_b.x - scr_b.x) > 5.00 &&
						Math.abs(prev_scr_b.y - scr_b.y) > 5.00
		
		// If we are to start a new trace, merely move to its start;
		// continue the old trace otherwise
		trace.setAttribute("d", d + (new_trace? " M ":" L ")
							+ scr_b.x + " " + scr_b.y)

		prev_scr_b = scr_b
	}
})()

this.move_all = function()
{
	var scr_b = move_bloch_vector()
	move_projections(scr_b)
	correct_depth_order()
	if(this.trace_on) 
		trace_add_node(scr_b)
}

} // end SpinView

s = new Spin
sv = new SpinView(s, document)

var Wx, Wy, Wz; Wx = Wy = Wz = 0
const W = 0.5e-3

var prev_t = null

function animation_step(t) /* [t] = ms */
{
	var dt

	if (!prev_t) prev_t = t
	else if (Wx != 0 || Wy != 0 || Wz != 0){
		dt = t - prev_t; prev_t = t

		// Don't move if we were idling for too much, e.g. the window was 
		// inactive for some time
		if(W*dt < 0.1) { 
			s.advance_paulis(dt, Wx, Wy, Wz)
			sv.move_all()
		}
	}

	window.requestAnimationFrame(animation_step)
}

window.requestAnimationFrame(animation_step)

// Applies a sequence of pulses.
// An argument is an array of objects [{axis:[x,y,z], phi:angle}, ...].
// Here x, y, z give the rotation axis direction; phi is the rotation angle
function pulse_seq(vs)
{	
	function normalize(v)
	{	
		len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
		v[0] /= len; v[1] /= len; v[2] /= len
	}
		
	if(!vs.length) {
		Wx = Wy = Wz = 0
		return
	}

	normalize(vs[0].axis)

	Wx = W * vs[0].axis[0]
	Wy = W * vs[0].axis[1]
	Wz = W * vs[0].axis[2]

	window.setTimeout(function () { pulse_seq(vs.slice(1)) }, vs[0].phi/W)
}

</script>

</body>
</html>
